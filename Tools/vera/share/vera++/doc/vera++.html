<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
  body
  {
    background: white;
    margin: 0px;
    padding: 20px;
    font-family: sans-serif;
    font-size: smaller;
  }
  
  h1
  {
    background-color: #f4fafa;
    padding: 5px 10px 5px 10px;
  }
  
  p
  {
    padding-left: 10px;
  }
  
  pre
  {
    margin: 10px;
    background-color: #f4fafa;
    border: 1px dotted blue;
    padding: 10px;
  }
  
  li
  {
    margin: 10px;
  }
  </style>
</head>
<body>
<h1 id="introduction">Introduction</h1>
<p>Vera++ is a programmable tool for verification, analysis and transformation of C++ source code.</p>
<p>The main usage scenarios that are foreseen for Vera++ are:</p>
<ul>
<li>Ensure that the source code complies with the given <em>coding standards and conventions</em>.</li>
<li>Provide source code <em>metrics and statistics</em>.</li>
<li>Perform automated <em>transformations</em> of the source code, which can range from <em>pretty-printing</em> to <em>diagnostics</em> to <em>fault injection</em> and advanced testing.</li>
</ul>
<p>The main design idea of Vera++ is to create a generic engine that will be able to parse the C++ code and present it in the form of collections of various objects to user provided <em>scripts</em> that will define the concrete actions to be executed.</p>
<p>Currently the following object collections are provided:</p>
<ul>
<li>Collection of source <em>file names</em>.</li>
<li>Collection of <em>source lines</em> for each file.</li>
<li>Collection of identified <em>tokens</em> in each file.</li>
</ul>
<p><strong>Note:</strong> It is foreseen that future versions of Vera++ will provide also the semantic view on the code.</p>
<p>The most important feature of Vera++ is that all activities other than code parsing are defined by scripts. This means that Vera++ is <em>flexible</em> and <em>extensible</em>.</p>
<p>For example, compliance with coding standards can be expressed in terms of <em>rules</em>, each being defined by a separate script. The scripts can access all collections listed above and perform actions related to the given rule. The user can ask to run any given script or some defined set of scripts in a single program execution.</p>
<p>As a simple example, a coding convention that limits the length of the source line can be implemented as a script that traverses the collection of files and the collection of source lines and checks whether each source line fits within the given limits. A report can be generated for each non-conforming line of code so that the user gets a clear information about where the problem is located.</p>
<p>All existing rules present their reports in the format that is compatible with regular compiler's output, so that it is easy to integrate Vera++ with the existing build framework.</p>
<p>Similarly, automated transformation procedures are implemented as separate scripts that scan the above collections and produce another source files according to their algorithms. A simple example of such transformation might be a script that removes empty lines from source code.</p>
<p>The Tcl programming language is currently supported for scripts that run within Vera++.</p>
<h1 id="running-vera">Running Vera++</h1>
<p>Vera++ needs to know where the rules and transformation scripts are located. The following rules are applied:</p>
<ul>
<li>If the <code>--root</code> option is used, its argument is used as the name of the directory where the <code>scripts</code> subdirectory with scripts should be located, otherwise</li>
<li>If the <code>VERA_ROOT</code> environment variable is defined, it is used as the name of the directory where the <code>scripts</code> subdirectory with scripts should be located, otherwise</li>
<li>If the <code>HOME</code> environment variable is defined, then the <code>~/.vera++</code> directory is used (and it should contain the <code>scripts</code> subdirectory with scripts), otherwise</li>
<li>The current directory should contain the <code>scripts</code> subdirectory.</li>
</ul>
<h2 id="options">Options</h2>
<p>Vera++ recognizes the following parameters:</p>
<dl>
<dt><code>-</code></dt>
<dd>(a single minus) indicates that the source code to check will be provided on the stdin.
</dd>
<dt><code>-p</code> <code>--profile</code> <em>profilename</em></dt>
<dd>instructs the program to execute all rules defined in the given profile; the profile name is just a name of the file that will be found under the <code>profiles</code> directory. There is always a <code>default</code> profile that lists many of the existing rules - it is used when no profile is named explicitly.
</dd>
<dt><code>-R</code> <code>--rule</code> <em>rulename</em></dt>
<dd>instructs the program to execute the given rule; note that the name of the rule should not contain the file extension of the script implementing the rule - this is added automatically, so that for example <code>--rule my_rule</code> means that Vera++ will find the <code>my_rule.tcl</code> script and will run it.
</dd>
<dt><code>--transform</code> <em>transformationname</em></dt>
<dd>instructs the program to execute a single named transformation; the naming scheme is the same as for the <code>--rule</code> option.
</dd>
<dt><code>-o</code> <code>--std-report</code> <em>filename</em></dt>
<dd>writes the standard (gcc-like) report to this file. A single dash <code>-</code> means that the standard output or the error output will be used, depending on the usage of the <code>--warning</code> or <code>--error</code> option. This option may be used several times in order to produce the reports in several locations - for example on the standard output and in a file. Default value is <code>-</code>.
</dd>
<dt><code>-v</code> <code>--vc-report</code> <em>filename</em></dt>
<dd>writes the Visual C report to this file. A single dash <code>-</code> means that the standard output or the error output will be used, depending on the usage of the <code>--warning</code> or <code>--error</code> option. This option may be used several times in order to produce the reports in several locations - for example on the standard output and in a file. This report is not produced by default.
</dd>
<dt><code>-x</code> <code>--xml-report</code> <em>filename</em></dt>
<dd>writes the XML report to this file. Not used by default. A single dash <code>-</code> means that the standard output or the error output will be used, depending on the usage of the <code>--warning</code> or <code>--error</code> option. This option may be used several times in order to produce the reports in several locations - for example on the standard output and in a file. This report is not produced by default.
</dd>
<dt><code>-c</code> <code>--checkstyle-report</code> <em>filename</em></dt>
<dd>writes the checkstyle report to this file. Not used by default. A single dash <code>-</code> means that the standard output or the error output will be used, depending on the usage of the <code>--warning</code> or <code>--error</code> option. This option may be used several times in order to produce the reports in several locations - for example on the standard output and in a file. This report is not produced by default.
</dd>
<dt><code>-s</code> <code>--show-rule</code></dt>
<dd>includes the name of the rule in each report line.
</dd>
<dt><code>-d</code> <code>--no-duplicate</code></dt>
<dd>instructs the program to omit duplicated messages in the final report (the duplicates can be a result of violating the same rule many times in the same line of source code).
</dd>
<dt><code>-w</code> <code>--warning</code></dt>
<dd>reports are marked as warning and generated on the error output.
</dd>
<dt><code>-e</code> <code>--error</code></dt>
<dd>reports are marked as error and generated on the error output. An non zero exit code is used when one or more reports are generated.
</dd>
<dt><code>-q</code> <code>--quiet</code></dt>
<dd>don't display the reports. This option is best used with <code>--summary</code> and/or with <code>--error</code>.
</dd>
<dt><code>-S</code> <code>--summary</code></dt>
<dd>displays the number of reports and the number of processed files.
</dd>
<dt><code>--parameters</code> <em>filename</em></dt>
<dd>instructs the program to read parameter values from the given file; each parameter association should be placed in a separate line of this file. This option may be used several times.
</dd>
<dt><code>-P</code> <code>--parameter</code> <em>parameterassociation</em></dt>
<dd>provides the value of the named parameter to the scripts (see the documentation of each script to see whether it recognizes any parameters); the parameter association has the form <code>name=value</code>.
</dd>
<dt><code>--exclusions</code> <em>exclusionsfilename</em></dt>
<dd><p>instructs the program to exclude some source files from rule checks, as described in the given file; the content of this file is a set of regular expressions that match the log output in the standard format, with the rule name. If the regular expression matches, the report is excluded. For example, to exclude all the <code>T003</code> report for the <code>case</code> and <code>delete</code> keywords, just add this line to an exclusion file</p>
<p>:+: T003: keyword '(case|delete)' not followed by a single space</p>
</dd>
</dl>
<p>The empty lines are ignored in the exclusion files as well as the lines beginning with a <code>#</code>, so the file can be commented.</p>
<dl>
<dt><code>-i</code> <code>--inputs</code> <em>filename</em></dt>
<dd>the inputs are read from that file. A single dash <code>-</code> means that the files to check will be read from the standard input. This option may be used several times.
</dd>
<dt><code>-r</code> <code>--root</code> <em>path</em></dt>
<dd>uses the given path as the vera++ root directory
</dd>
<dt><code>--version</code></dt>
<dd>prints the program version information and exits.
</dd>
<dt><code>-h</code> <code>--help</code></dt>
<dd>prints the list of recognized options and exits.
</dd>
<dt><code>--</code></dt>
<dd>(a double dash) do not interpret any more arguments as options.
</dd>
</dl>
<p>Arguments that are not starting with a dash <code>-</code> are treated as source files to check. Files starting with a dash can be checked by prefixing them with the current directory shortcut <code>./</code>.</p>
<p>When no input file is provided either as an argument or with the <code>--input</code> option, the list of source file names is read from the standard input.</p>
<h2 id="profile-file">Profile file</h2>
<p>The profile file contains a list of options and their value. The available options are the same as the options used on the command line in their long form and without the leading <code>--</code>. The options noted as being usable several times are also usable several times in the profile file. An example profile definition that groups three rules (L001, L002 and L003) and changes the maximum line length to 120 might look like:</p>
<pre><code>rule=L001
rule=L002
rule=L003
parameter=max-line-length=120</code></pre>
<h2 id="examples-of-executing-vera-with-rules">Examples of executing Vera++ with rules</h2>
<p>To execute all default verification rules against the file <code>file.cpp</code>, run:</p>
<pre><code>vera++ file.cpp</code></pre>
<p>To execute only rule <code>L001</code> (this rule ensures that there is no trailing whitespace in each source line) against the same file, run:</p>
<pre><code>vera++ -R L001 file.cpp</code></pre>
<p>To execute rule <code>L004</code> (this rule checks for too long source lines) with the parameter value providing 78 as the maximum line length, run:</p>
<pre><code>vera++ -R L004 -P max-line-length=78 file.cpp</code></pre>
<p>To execute all rules from your favorite profile (assuming that the <code>my_favorite</code> profile definition is stored in the <code>profiles</code> directory) against all header files in the current filesystem subtree, run:</p>
<pre><code>find . -name &#39;*.h&#39; | vera++ --profile my_favorite</code></pre>
<p><strong>Note:</strong> Vera++ collects the reports generated by each rule and prints them out sorted and after all rules were executed. If there were no problem reports, the output of the program is empty.</p>
<p><strong>Note:</strong> Vera++ reports are generated on the standard output by default, making them easy to use with a pipe. The <code>--warning</code> and <code>--error</code> options are changing the output to the standard error. The options <code>--std-report</code>, <code>--vc-report</code>, <code>--xml-report</code> and <code>--quiet</code> may be used to disable the output to the standard or error output.</p>
<h2 id="examples-of-executing-vera-with-transformations">Examples of executing Vera++ with transformations</h2>
<p>To execute the <code>trim_right</code> source code transformation (it removes the trailing whitespace that the rule <code>L001</code> above complained about) on all <code>.cpp</code> files in the current directory run:</p>
<pre><code>vera++ --transform trim_right *.cpp</code></pre>
<p>As a result, each <code>.cpp</code> file will be backed up with the additional extension <code>.bak</code> and the files will be trimmed by removing trailing whitespace. The exact behavior is defined by the script named <code>trim_right.tcl</code> in the <code>scripts/transformations</code> directory.</p>
<h2 id="running-vera-as-a-test-with-cmake">Running Vera++ as a test with CMake</h2>
<p>CMake offers the possibility to run tests that are considered to pass when they return a 0 value and to fail otherwise. Fortunately, vera++, when used with the <code>--error</code> option, has exactly this behavior. Creating the test is just a matter of listing the sources to check:</p>
<pre><code>file(GLOB_RECURSE srcs
  ${CMAKE_SOURCE_DIR}/src/*.cpp
  ${CMAKE_SOURCE_DIR}/src/*.h)
add_test(NAME VeraStyle
  COMMAND vera++
  --error
  ${srcs})</code></pre>
<h2 id="running-vera-during-the-build-with-cmake">Running Vera++ during the build with CMake</h2>
<p>Running vera++ in a test integrates quite badly with the IDEs or with <a href="http://cdash.org">CDash</a>: the reports are hidden in the test log, and it is not easy to look at the problematic code. Moreover, a failure in the coding style is not the same as a failure in a unit or functional test, and shouldn't appear in the same way. Another option is to run vera++ during the build and make it generate warnings that are well interpreted by the IDEs and CDash. In QtCreator for instance, it is then possible to click on the warning to go to the problematic code.</p>
<p>Running vera++ during the build can be done in a similar way to the previous section, by replacing the <code>add_test()</code> call with a <code>add_custom_target()</code> that will run the style check every time the custom target is built.</p>
<pre><code>file(GLOB_RECURSE srcs
  ${CMAKE_SOURCE_DIR}/src/*.cpp
  ${CMAKE_SOURCE_DIR}/src/*.h)
add_custom_target(VeraStyle ALL
  vera++
  --warning
  ${srcs})</code></pre>
<p>For large projects, running the style check every time can be quite time consuming and uncomfortable for the developer. It is then more convenient to split the style check in several parts that can be run in parallel, and to avoid rerunning the check if the files to check have not been modified. A vera++ macro is available to do that very easily:</p>
<pre><code>find_package(vera++)
include(${VERA++_USE_FILE})
add_vera_targets(*.h *.cpp
  RECURSE
  ROOT &quot;${CMAKE_SOURCE_DIR}&quot;)</code></pre>
<p>This macro adds a new <code>style_reports</code> target that is run every time a source file is modified. A <code>style</code> target is still available to force the style check. The target names can be configured with the parameters <code>NAME</code> and <code>NAME_ALL</code>. This macro is the recommended way to use vera++ with CMake.</p>
<h2 id="backward-compatibility-with-vera-1.2">Backward compatibility with vera++ 1.2</h2>
<ul>
<li>Tcl exclusion files are still supported, but deprecated</li>
<li>Tcl profiles are still supported, but deprecated</li>
</ul>
<h2 id="backward-compatibility-with-vera-1.1">Backward compatibility with vera++ 1.1</h2>
<p>Vera++ is still mostly compatible with the vera++ 1.1 command line interface, but this feature is planned for removal and its usage is not recommended.</p>
<p>Vera++ tries to detect if the old command line style is used by searching for the old options in the arguments. If no old style option is found, vera++ uses the new command line parser.</p>
<p>The command line style can be forced to the old style by setting the environment variable <code>VERA_LEGACY</code> to <code>on</code>, <code>true</code> or <code>1</code>. Any other value will force vera++ to use the new command line style.</p>
<p>Note: the behavior of vera++ is not backward compatible with vera++ 1.1 when no option is passed to vera++ and <code>VERA_LEGACY</code> is not set:</p>
<ul>
<li>the reports are generated on the standard output instead of the error output;</li>
<li>a single dash <code>-</code> means that the source code to check is read from the standard input instead of reading the list of files to check;</li>
<li>the lack of input files makes vera++ read the standard input instead of generating an error.</li>
</ul>
<h1 id="rules">Rules</h1>
<h2 id="f001-source-files-should-not-use-the-r-cr-character">F001 Source files should not use the '\r' (CR) character</h2>
<p>As a commonly accepted practice, line breaks are denoted by a single '\n' (LF) character or by two characters &quot;\r\n&quot; (CRLF). A single appearance of '\r' (CR) is discouraged.</p>
<p><strong>Compliance:</strong> Boost</p>
<h2 id="f002-file-names-should-be-well-formed">F002 File names should be well-formed</h2>
<p>The source file names should be well-formed in the sense of their allowed maximum length and directory depth. Directory and file names should start with alphabetic character or underscore. In addition, directory names should not contain dots and file names can have only one dot.</p>
<p><strong>Recognized parameters:</strong></p>
<pre><code>Name                    Default   Description
----------------------- --------- -------------------------------------------------
max-directory-depth     8         Maximum depth of the directory structure.
max-dirname-length      31        Maximum length of the directory path component.
max-filename-length     31        Maximum length of the leaf file name.
max-path-length         100       Maximum length of the full path.</code></pre>
<p><strong>Compliance:</strong> Boost</p>
<h2 id="l001-no-trailing-whitespace">L001 No trailing whitespace</h2>
<p><em>Trailing whitespace</em> is any whitespace character (space or tab) that is placed at the end of the source line, after other characters or alone.</p>
<p>The presence of <em>trailing whitespace</em> artificially influences some source code metrics and is therefore discouraged.</p>
<p>As a special case, the trailing whitespace in the otherwise empty lines is allowed provided that the amount of whitespace is identical to the indent in the previous line - this exception is more friendly with less smart editors, but can be switched off by setting non-zero value for the <code>strict-trailing-space</code> parameter.</p>
<p><strong>Recognized parameters:</strong></p>
<pre><code>Name                      Default   Description
------------------------- --------- --------------------------------------
strict-trailing-space     0         Strict mode for trailing whitespace.</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="l002-dont-use-tab-characters">L002 Don't use tab characters</h2>
<p><em>Horizontal tabs</em> are not consistently handled by editors and tools. Avoiding them ensures that the intended formatting of the code is preserved.</p>
<p><strong>Compliance:</strong> HICPP, JSF</p>
<h2 id="l003-no-leading-and-no-trailing-empty-lines">L003 No leading and no trailing empty lines</h2>
<p><em>Leading and trailing empty lines</em> confuse users of various tools (like <code>head</code> and <code>tail</code>) and artificially influence some source code metrics.</p>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="l004-line-cannot-be-too-long">L004 Line cannot be too long</h2>
<p>The source code line should not exceed some <em>reasonable</em> length.</p>
<p><strong>Recognized parameters:</strong></p>
<pre><code>Name                Default   Description
------------------- --------- -------------------------------------
max-line-length     100       Maximum length of source code line.</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="l005-there-should-not-be-too-many-consecutive-empty-lines">L005 There should not be too many consecutive empty lines</h2>
<p>The empty lines (if any) help to introduce more &quot;light&quot; in the source code, but they should not be overdosed in the sense that too many consecutive empty lines make the code harder to follow.</p>
<p>Lines containing only whitespace are considered to be empty in this context.</p>
<p><strong>Recognized parameters:</strong></p>
<pre><code>Name                            Default   Description
------------------------------- --------- --------------------------------------------
max-consecutive-empty-lines     2         Maximum number of consecutive empty lines.</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="l006-source-file-should-not-be-too-long">L006 Source file should not be too long</h2>
<p>The source file should not exceed a <em>reasonable</em> length.</p>
<p>Long source files can indicate an opportunity for refactoring.</p>
<p><strong>Recognized parameters:</strong></p>
<pre><code>Name                Default   Description
------------------- --------- ------------------------------------
max-file-length     2000      Maximum number of lines in a file.</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t001-one-line-comments-should-not-have-forced-continuation">T001 One-line comments should not have forced continuation</h2>
<p>The one-line comment is a comment that starts with <code>//</code>.</p>
<p>The usual intent is to let the comment continue till the end of the line, but the preprocessing rules of the language allow to actually continue the comment in the next line if <em>line-splicing</em> is forced with the backslash at the end of the line:</p>
<pre><code>void foo()
{
    // this comment is continued in the next line \
    exit(0);
}</code></pre>
<p>It is not immediately obvious what happens in this example. Moreover, the line-splicing works only if the backslash is really the last character in the line - which is error prone because any white characters that might appear after the backslash will change the meaning of the program without being visible in the code.</p>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t002-reserved-names-should-not-be-used-for-preprocessor-macros">T002 Reserved names should not be used for preprocessor macros</h2>
<p>The C++ Standard reserves some forms of names for language implementations. One of the most frequent violations is a definition of preprocessor macro that begins with underscore followed by a capital letter or containing two consecutive underscores:</p>
<pre><code>#define _MY_MACRO something
#define MY__MACRO something</code></pre>
<p>Even though the majority of known compilers use more obscure names for internal purposes and the above code is not likely to cause any significant problems, all such names are <em>formally reserved</em> and therefore should not be used.</p>
<p>Apart from the use of underscore in macro names, preprocessor macros should not be used to redefine language keywords:</p>
<pre><code>#define private public
#define const</code></pre>
<p><strong>Compliance:</strong> ISO</p>
<h2 id="t003-some-keywords-should-be-followed-by-a-single-space">T003 Some keywords should be followed by a single space</h2>
<p>Keywords from the following list:</p>
<ul>
<li><code>case</code></li>
<li><code>class</code></li>
<li><code>delete</code></li>
<li><code>enum</code></li>
<li><code>explicit</code></li>
<li><code>extern</code></li>
<li><code>goto</code></li>
<li><code>new</code></li>
<li><code>struct</code></li>
<li><code>union</code></li>
<li><code>using</code></li>
</ul>
<p>should be followed by a single space for better readability.</p>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t004-some-keywords-should-be-immediately-followed-by-a-colon">T004 Some keywords should be immediately followed by a colon</h2>
<p>Keywords from the following list:</p>
<ul>
<li><code>default</code></li>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>public</code></li>
</ul>
<p>should be immediately followed by a colon, unless used in the list of base classes:</p>
<pre><code>class A : public B, private C
{
public:
     A();
     ~A();
protected:
     // ...
private:
     // ...
};

void fun(int a)
{
     switch (a)
     {
     // ...
     default:
          exit(0);
     }
}</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t005-keywords-break-and-continue-should-be-immediately-followed-by-a-semicolon">T005 Keywords break and continue should be immediately followed by a semicolon</h2>
<p>The <code>break</code> and <code>continue</code> keywords should be immediately followed by a semicolon, with no other tokens in between:</p>
<pre class="example"><code>while (...)
{
     if (...)
     {
          break;
     }
     if (...)
     {
          continue;
     }
     // ...
}</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t006-keywords-return-and-throw-should-be-immediately-followed-by-a-semicolon-or-a-single-space">T006 Keywords return and throw should be immediately followed by a semicolon or a single space</h2>
<p>The <code>return</code> and <code>throw</code> keywords should be immediately followed by a semicolon or a single space:</p>
<pre class="example"><code>void fun()
{
     if (...)
     {
          return;
     }
     // ...
}

int add(int a, int b)
{
     return a + b;
}</code></pre>
<p>An exception to this rule is allowed for exeption specifications:</p>
<pre class="example"><code>void fun() throw();</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t007-semicolons-should-not-be-isolated-by-spaces-or-comments-from-the-rest-of-the-code">T007 Semicolons should not be isolated by spaces or comments from the rest of the code</h2>
<p>The semicolon should not stand isolated by whitespace or comments from the rest of the code.</p>
<pre class="example"><code>int a ;     // bad
int b
;           // bad
int c;      // OK</code></pre>
<p>As an exception from this rule, semicolons surrounded by spaces are allowed in <code>for</code> loops:</p>
<pre class="example"><code>for ( ; ; ) // OK as an exception
{
    // ...
}</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t008-keywords-catch-for-if-switch-and-while-should-be-followed-by-a-single-space">T008 Keywords catch, for, if, switch and while should be followed by a single space</h2>
<p>Keywords <code>catch</code>, <code>for</code>, <code>if</code>, <code>switch</code> and <code>while</code> should be followed by a single space and then an opening left parenthesis:</p>
<pre class="example"><code>catch (...)
{
     for (int i = 0; i != 10; ++i)
     {
          if (foo(i))
          {
               while (getline(cin, line))
               {
                    switch (i % 3)
                    {
                    case 0:
                         bar(line);
                         break;
                    // ...
                    }
               }
          }
     }
}</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t009-comma-should-not-be-preceded-by-whitespace-but-should-be-followed-by-one">T009 Comma should not be preceded by whitespace, but should be followed by one</h2>
<p>A comma, whether used as operator or in various lists, should not be preceded by whitespace on its left side, but should be followed by whitespace on its right side:</p>
<pre class="example"><code>void fun(int x, int y, int z);
int a[] = {5, 6, 7};
class A : public B,
          public C
{
     // ...
};</code></pre>
<p>An exception to this rule is allowed for <code>operator,</code>:</p>
<pre class="example"><code>struct A {};
void operator,(const A &amp;left, const A &amp;right);</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t010-identifiers-should-not-be-composed-of-l-and-o-characters-only">T010 Identifiers should not be composed of 'l' and 'O' characters only</h2>
<p>The characters 'l' (which is lowercase 'L') and 'O' (which is uppercase 'o') should not be the only characters used in the identifier, because this would make them visually similar to numeric literals.</p>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t011-curly-brackets-from-the-same-pair-should-be-either-in-the-same-line-or-in-the-same-column">T011 Curly brackets from the same pair should be either in the same line or in the same column</h2>
<p>Corresponding curly brackets should be either in the same line or in the same column. This promotes clarity by emphasising scopes, but allows concise style of one-line definitions and empty blocks:</p>
<pre class="example"><code>class MyException {};

struct MyPair
{
    int a;
    int b;
};

enum state { close, open };

enum colors
{
    black,
    red,
    green,
    blue,
    white
};</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t012-negation-operator-should-not-be-used-in-its-short-form">T012 Negation operator should not be used in its short form</h2>
<p>The negation operator (exclamation mark) reduces readability of the code due to its terseness. Prefer explicit logical comparisons or alternative tokens for increased readability:</p>
<pre class="example"><code>if (!cond)         // error-prone
if (cond == false) // better
if (not cond)      // better (alternative keyword)</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h2 id="t013-source-files-should-contain-the-copyright-notice">T013 Source files should contain the copyright notice</h2>
<p>The copyright notice is required by man coding standards and guidelines. In some countries every written artwork has some copyright, even if implicit. Prefer explicit notice to avoid any later confusion.</p>
<p>This rule verifies that at least one comment in the source file contains the &quot;copyright&quot; word.</p>
<p><strong>Compliance:</strong> Boost</p>
<h2 id="t014-source-files-should-refer-the-boost-software-license">T014 Source files should refer the Boost Software License</h2>
<p>The Boost Software License should be referenced in the source code.</p>
<p>This rule verifies that at least one comment in the source file contains the &quot;Boost Software License&quot; phrase.</p>
<p>Note that this rule is very specific to the Boost libraries and those project that choose to use the Boost license. It is therefore not part of the default profile.</p>
<p><strong>Compliance:</strong> Boost</p>
<h2 id="t015-html-links-in-comments-and-string-literals-should-be-correct">T015 HTML links in comments and string literals should be correct</h2>
<p>The links embedded in comments and string literals should have correct form and should reference existing files.</p>
<p><strong>Compliance:</strong> Boost</p>
<h2 id="t016-calls-to-minmax-should-be-protected-against-accidental-macro-substitution">T016 Calls to min/max should be protected against accidental macro substitution</h2>
<p>The calls to min and max functions should be protected against accidental macro substitution.</p>
<pre class="example"><code>x = max(y, z); // wrong, vulnerable to accidental macro substitution

x = (max)(y, z); // OK

x = max BOOST_PREVENT_MACRO_SUBSTITUTION (y, z); // OK</code></pre>
<p><strong>Compliance:</strong> Boost</p>
<h2 id="t017-unnamed-namespaces-are-not-allowed-in-header-files">T017 Unnamed namespaces are not allowed in header files</h2>
<p>Unnamed namespaces are not allowed in header files.</p>
<p>The typical use of unnamed namespace is to hide module-internal names from the outside world. Header files are physically concatenated in a single translation unit, which logically merges all namespaces with the same name. Unnamed namespaces are also merged in this process, which effectively undermines their initial purpose.</p>
<p>Use named namespaces in header files. Unnamed namespaces are allowed in implementation files only.</p>
<p><strong>Compliance:</strong> Boost</p>
<h2 id="t018-using-namespace-is-not-allowed-in-header-files">T018 Using namespace is not allowed in header files</h2>
<p>Using namespace directives are not allowed in header files.</p>
<p>The using namespace directive imports names from the given namespace and when used in a header file influences the global namespace of all the files that directly or indirectly include this header file.</p>
<p>It is imaginable to use the using namespace directive in a limited scope in a header file (for example in a template or inline function definition), but for the sake of consistency this is also discouraged.</p>
<p><strong>Compliance:</strong> C++ Coding Standards</p>
<h2 id="t019-control-structures-should-have-complete-curly-braced-block-of-code">T019 Control structures should have complete curly-braced block of code</h2>
<p>Control structures managed by for, if and while constructs can be associated with a single instruction or with a complex block of code. Standardizing on the curly-braced blocks in all cases allows one to avoid common pitfalls and makes the code visually more uniform.</p>
<pre class="example"><code>if (x) foo();     // bad style
if (x) { foo(); } // OK

if (x)
    foo();        // again bad style

if (x)
{                 // OK
    foo();
}

if (x)
    while (y)     // bad style
        foo();    // bad style

if (x)
{                 // OK
    while (y)
    {             // OK
        foo();
    }
}

for (int i = 0; i = 10; ++i);  // oops!
    cout &lt;&lt; &quot;Hello\n&quot;;

for (int i = 0; i = 10; ++i)   // OK
{
    cout &lt;&lt; &quot;Hello\n&quot;;
}</code></pre>
<p><strong>Compliance:</strong> Inspirel</p>
<h1 id="transformations">Transformations</h1>
<h2 id="move_includes-change-prefix-of-include-paths">move_includes Change prefix of #include paths</h2>
<p>This transformation allows one to modify the prefix of file paths in #include directives.</p>
<p>The motivation for this transformation is to help move whole libraries from one file tree to another.</p>
<p>Please use this transformation as a boilerplate for your own customized version.</p>
<p>For example, the following file:</p>
<pre><code>#include &quot;boost/shared_ptr.hpp&quot;
#include &quot;boost/bind.hpp&quot;</code></pre>
<p>will be transformed into:</p>
<pre><code>#include &quot;boom/shared_ptr.hpp&quot;
#include &quot;boom/bind.hpp&quot;</code></pre>
<p>Note: The transformation is performed in place, which means that the source files are modified.</p>
<h2 id="move_macros-change-prefix-in-macros">move_macros Change prefix in macros</h2>
<p>This transformation allows one to modify the prefix of macros.</p>
<p>The motivation for this transformation is to help move whole libraries or source sets from one naming conventioin to another.</p>
<p>Please use this transformation as a boilerplate for your own customized version.</p>
<p>For example, the following file:</p>
<pre><code>#define BOOST_SOME_MACRO 1
// ...
#ifdef BOOST_SOME_MACRO
// ...
#endif</code></pre>
<p>will be transformed into:</p>
<pre><code>#define BOOM_SOME_MACRO 1
// ...
#ifdef BOOM_SOME_MACRO
// ...
#endif</code></pre>
<p>Note: This transformation actually does not check whether the given identifier is indeed a macro name and the prefix replacement is performed systematically on all identifiers that match.</p>
<p>Note: The transformation is performed in place, which means that the source files are modified.</p>
<h2 id="move_namespace-change-namespace-name">move_namespace Change namespace name</h2>
<p>This transformation allows one to consistently change the namespace name.</p>
<p>The motivation for this transformation is to help move whole libraries or source sets from one namespace to another, for example to allow the coexistence of two different version of the same library.</p>
<p>Please use this transformation as a boilerplate for your own customized version.</p>
<p>For example, the following file:</p>
<pre><code>namespace boost
{
void foo();
}

void boost::foo() {/* ... */}</code></pre>
<p>will be transformed into:</p>
<pre><code>namespace boom
{
void foo();
}

void boom::foo() {/* ... */}</code></pre>
<p>Note: This transformation actually does not check whether the given identifier is indeed a namespace name and the replacement is performed systematically on all identifiers that match. Do not use it on code that overloads namespace names for other purposes.</p>
<p>Note: The transformation is performed in place, which means that the source files are modified.</p>
<h2 id="to_lower-change-identifier-naming-convention-from-camelcase-to-standard_lowercase">to_lower Change identifier naming convention from CamelCase to standard_lowercase</h2>
<p>This transformation allows one to modify the naming convention of all identifiers from CamelCase to standard_lowercase, as used by the standard library or Boost.</p>
<p>For example, the following code:</p>
<pre><code>namespace MyTools
{

class MyClass
{
public:
    void myFunction();
};

}</code></pre>
<p>will be transformed into this:</p>
<pre><code>namespace my_tools
{

class my_class
{
public:
    void my_function();
};

}</code></pre>
<p>Note: The transformation is performed in place, which means that the source files are modified.</p>
<p>Note: This transformation does not modify comments and string literals.</p>
<h2 id="to_xml-transform-c-code-into-xml">to_xml Transform C++ code into XML</h2>
<p>This transformation generates a XML tree where nodes relate to C++ source code tokens.</p>
<p>For example, the following file (file.cpp):</p>
<pre><code>#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;Hello World\n&quot;;
}</code></pre>
<p>will be transformed into new file named file.cpp.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;cpp-source file-name=&quot;test.cpp&quot;&gt;
    &lt;token name=&quot;pp_hheader&quot; line=&quot;1&quot; column=&quot;0&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/token&gt;
    &lt;token name=&quot;newline&quot; line=&quot;1&quot; column=&quot;19&quot;&gt;![CDATA[
]]&lt;/token&gt;
    &lt;token name=&quot;newline&quot; line=&quot;2&quot; column=&quot;0&quot;&gt;![CDATA[
]]&lt;/token&gt;
    &lt;token name=&quot;int&quot; line=&quot;3&quot; column=&quot;0&quot;&gt;int&lt;/token&gt;
    &lt;token name=&quot;space&quot; line=&quot;3&quot; column=&quot;3&quot;&gt; &lt;/token&gt;
    &lt;token name=&quot;identifier&quot; line=&quot;3&quot; column=&quot;4&quot;&gt;main&lt;/token&gt;
    &lt;token name=&quot;leftparen&quot; line=&quot;3&quot; column=&quot;8&quot;&gt;(&lt;/token&gt;
    &lt;token name=&quot;rightparen&quot; line=&quot;3&quot; column=&quot;9&quot;&gt;)&lt;/token&gt;
    &lt;token name=&quot;newline&quot; line=&quot;3&quot; column=&quot;10&quot;&gt;![CDATA[
]]&lt;/token&gt;
    &lt;token name=&quot;leftbrace&quot; line=&quot;4&quot; column=&quot;0&quot;&gt;{&lt;/token&gt;
    &lt;token name=&quot;newline&quot; line=&quot;4&quot; column=&quot;1&quot;&gt;![CDATA[
]]&lt;/token&gt;
    &lt;token name=&quot;space&quot; line=&quot;5&quot; column=&quot;0&quot;&gt;    &lt;/token&gt;
    &lt;token name=&quot;identifier&quot; line=&quot;5&quot; column=&quot;4&quot;&gt;std&lt;/token&gt;
    &lt;token name=&quot;colon_colon&quot; line=&quot;5&quot; column=&quot;7&quot;&gt;::&lt;/token&gt;
    &lt;token name=&quot;identifier&quot; line=&quot;5&quot; column=&quot;9&quot;&gt;cout&lt;/token&gt;
    &lt;token name=&quot;space&quot; line=&quot;5&quot; column=&quot;13&quot;&gt; &lt;/token&gt;
    &lt;token name=&quot;shiftleft&quot; line=&quot;5&quot; column=&quot;14&quot;&gt;&amp;lt;&amp;lt;&lt;/token&gt;
    &lt;token name=&quot;space&quot; line=&quot;5&quot; column=&quot;16&quot;&gt; &lt;/token&gt;
    &lt;token name=&quot;stringlit&quot; line=&quot;5&quot; column=&quot;17&quot;&gt;&quot;Hello World\n&quot;&lt;/token&gt;
    &lt;token name=&quot;semicolon&quot; line=&quot;5&quot; column=&quot;32&quot;&gt;;&lt;/token&gt;
    &lt;token name=&quot;newline&quot; line=&quot;5&quot; column=&quot;33&quot;&gt;![CDATA[
]]&lt;/token&gt;
    &lt;token name=&quot;rightbrace&quot; line=&quot;6&quot; column=&quot;0&quot;&gt;}&lt;/token&gt;
    &lt;token name=&quot;newline&quot; line=&quot;6&quot; column=&quot;1&quot;&gt;![CDATA[
]]&lt;/token&gt;
    &lt;token name=&quot;eof&quot; line=&quot;7&quot; column=&quot;0&quot;&gt;&lt;/token&gt;
&lt;/cpp-source&gt;</code></pre>
<p>Note: If the source code does not use line splicing, then concatenation of all XML node values is equivalent to the original C++ code.</p>
<h2 id="to_xml2-transform-c-code-into-xml-another-variant">to_xml2 Transform C++ code into XML (another variant)</h2>
<p>This transformation generates a XML tree where nodes relate to C++ source code tokens.</p>
<p>The difference between this version and the one named to_xml is that here nodes have names related to token types, which can make it easier for some further XML transformations.</p>
<p>For example, the following file (file.cpp):</p>
<pre><code>#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;Hello World\n&quot;;
}</code></pre>
<p>will be transformed into new file named file.cpp.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;cpp-source file-name=&quot;test.cpp&quot;&gt;
    &lt;pp_hheader line=&quot;1&quot; column=&quot;0&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/pp_hheader&gt;
    &lt;newline line=&quot;1&quot; column=&quot;19&quot;&gt;![CDATA[
]]&lt;/newline&gt;
    &lt;newline line=&quot;2&quot; column=&quot;0&quot;&gt;![CDATA[
]]&lt;/newline&gt;
    &lt;int line=&quot;3&quot; column=&quot;0&quot;&gt;int&lt;/int&gt;
    &lt;space line=&quot;3&quot; column=&quot;3&quot;&gt; &lt;/space&gt;
    &lt;identifier line=&quot;3&quot; column=&quot;4&quot;&gt;main&lt;/identifier&gt;
    &lt;leftparen line=&quot;3&quot; column=&quot;8&quot;&gt;(&lt;/leftparen&gt;
    &lt;rightparen line=&quot;3&quot; column=&quot;9&quot;&gt;)&lt;/rightparen&gt;
    &lt;newline line=&quot;3&quot; column=&quot;10&quot;&gt;![CDATA[
]]&lt;/newline&gt;
    &lt;leftbrace line=&quot;4&quot; column=&quot;0&quot;&gt;{&lt;/leftbrace&gt;
    &lt;newline line=&quot;4&quot; column=&quot;1&quot;&gt;![CDATA[
]]&lt;/newline&gt;
    &lt;space line=&quot;5&quot; column=&quot;0&quot;&gt;    &lt;/space&gt;
    &lt;identifier line=&quot;5&quot; column=&quot;4&quot;&gt;std&lt;/identifier&gt;
    &lt;colon_colon line=&quot;5&quot; column=&quot;7&quot;&gt;::&lt;/colon_colon&gt;
    &lt;identifier line=&quot;5&quot; column=&quot;9&quot;&gt;cout&lt;/identifier&gt;
    &lt;space line=&quot;5&quot; column=&quot;13&quot;&gt; &lt;/space&gt;
    &lt;shiftleft line=&quot;5&quot; column=&quot;14&quot;&gt;&amp;lt;&amp;lt;&lt;/shiftleft&gt;
    &lt;space line=&quot;5&quot; column=&quot;16&quot;&gt; &lt;/space&gt;
    &lt;stringlit line=&quot;5&quot; column=&quot;17&quot;&gt;&quot;Hello World\n&quot;&lt;/stringlit&gt;
    &lt;semicolon line=&quot;5&quot; column=&quot;32&quot;&gt;;&lt;/semicolon&gt;
    &lt;newline line=&quot;5&quot; column=&quot;33&quot;&gt;![CDATA[
]]&lt;/newline&gt;
    &lt;rightbrace line=&quot;6&quot; column=&quot;0&quot;&gt;}&lt;/rightbrace&gt;
    &lt;newline line=&quot;6&quot; column=&quot;1&quot;&gt;![CDATA[
]]&lt;/newline&gt;
    &lt;eof line=&quot;7&quot; column=&quot;0&quot;&gt;&lt;/eof&gt;
&lt;/cpp-source&gt;</code></pre>
<p>Note: If the source code does not use line splicing, then concatenation of all XML node values is equivalent to the original C++ code.</p>
<h2 id="trim_right-remove-trailing-white-space">trim_right Remove trailing white space</h2>
<p>This transformation removes the trailing whitespace from each line of code.</p>
<p>It can be treated as a quick remedy for problems reported by rule L001.</p>
<p>Note: The transformation is performed in place, which means that the source files are modified.</p>
<h1 id="script-api">Script API</h1>
<p>The scripts (rules and transformations) are written in Tcl, Lua or Python, and are executed by the embedded interpreter that has access to relevant state of the program. A set of commands is provided to enable easy read-only operation on the information that was gathered by parsing given source files.</p>
<p>In Tcl and Lua, the commands are usable without any prefix. In Python, the commands are available in the <code>vera</code> module. The vera module is already imported and does not need to be imported again in the rule code.</p>
<p>The following commands are provided:</p>
<ul>
<li><strong><code>getSourceFileNames</code></strong> - returns the list of file names that were provided to Vera++ as program parameters.</li>
<li><strong><code>getLineCount fileName</code></strong> - returns the number of lines in the given source file.</li>
<li><strong><code>getAllLines fileName</code></strong> - returns the list of lines, in their natural order, that form a give source file.</li>
<li><strong><code>getLine fileName lineNumber</code></strong> - returns the selected line; line numbers are counted from 1.</li>
<li><p><strong><code>getTokens fileName fromLine fromColumn toLine toColumn filter</code></strong> - returns the list of tokens, in their natural order, from the given source file and that match the given selection criteria.</p>
<p>The meaning of arguments for selecting tokens is:</p>
<ul>
<li><strong><code>fromLine</code></strong> - the lowest line number (counted from 1), inclusive</li>
<li><strong><code>fromColumn</code></strong> - the lowest column number (counted from 0), inclusive</li>
<li><strong><code>toLine</code></strong> - the highest line number, inclusive; -1 means that the selected range spans to the end of the file</li>
<li><strong><code>toColumn</code></strong> - the highest column number, exclusive; -1 means that the selected range spans to the end of the line defined by <code>toLine</code>.</li>
<li><strong><code>filter</code></strong> - the list of selected token types, the recognized token types are listed below; if this list is empty, then all token types are allowed.</li>
</ul>
<p>With Tcl, the <code>getTokens</code> command returns a list of lists - the nested lists have the following elements:</p>
<ul>
<li><em>value</em> - the literal text of the token</li>
<li><em>lineNumber</em> - the line number (from 1) where the token appears</li>
<li><em>columnNumber</em> - the column number (from 0) where the token appears</li>
<li><em>name</em> - the name or type of the token; see below for the list of recognized token types</li>
</ul>
<p>With Python and Lua, the <code>getTokens</code> command returns a list of token objects that have the following attributes:</p>
<ul>
<li><em>value</em> - the literal text of the token</li>
<li><em>line</em> - the line number (from 1) where the token appears</li>
<li><em>column</em> - the column number (from 0) where the token appears</li>
<li><em>name</em> - the name or type of the token; see below for the list of recognized token types</li>
<li><em>type</em> - same as <code>name</code></li>
</ul></li>
<li><strong><code>getParameter name defaultValue</code></strong> - returns the value of the given parameter or the provided default value if no such parameter is defined.</li>
<li><p><strong><code>report fileName lineNumber message</code></strong> - registers a report for the given file and line; this report is printed at the end of the program execution, sorted by file and line number. Use this command to generate output that is compatible with the warning/error output format of popular compilers.</p></li>
</ul>
<h2 id="examples">Examples:</h2>
<p>To process all lines from all source files, use the following code pattern:</p>
<p>Tcl:</p>
<pre><code>foreach fileName [getSourceFileNames] {
    foreach line [getAllLines $fileName] {
        # ...
    }
}</code></pre>
<p>Python:</p>
<pre><code>for f in vera.getSourceFileNames():
  for line in vera.getAllLines(f):
    # ...</code></pre>
<p>Lua:</p>
<pre><code>for file in getSourceFileNames() do
  for line in getAllLines(file) do
    -- ...
  end
end</code></pre>
<p>To process all tokens from all source files, use:</p>
<p>Tcl:</p>
<pre><code>foreach fileName [getSourceFileNames] {
    foreach token [getTokens $fileName 1 0 -1 -1 {}] {
        set tokenValue [lindex $token 0]
        set lineNumber [lindex $token 1]
        set columnNumber [lindex $token 2]
        set tokenType [lindex $token 3]
        # ...
    }
}</code></pre>
<p>Python:</p>
<pre><code>for f in vera.getSourceFileNames():
  for t in for t in vera.getTokens(fileName, 1, 0, -1, -1, []):
    # print t.line, t.type, ...</code></pre>
<p>Lua:</p>
<pre><code>for fileName in getSourceFileNames() do
  for t in getTokens(fileName, 1, 0, -1, -1, filter) do
    -- t.line, t.type, ...
  end
end</code></pre>
<p>To process only curly braces from the given source file, use:</p>
<p>Tcl:</p>
<pre><code>foreach token [getTokens $fileName 1 0 -1 -1 {leftbrace rightbrace}] {
    # ...
}</code></pre>
<p>Python:</p>
<pre><code>for t in for t in vera.getTokens(fileName, 1, 0, -1, -1, [&quot;leftbrace&quot;, &quot;rightbrace&quot;]):
  # ...</code></pre>
<p>Lua:</p>
<pre><code>for t in getTokens(fileName, 1, 0, -1, -1, {&quot;leftbrace&quot;, &quot;rightbrace&quot;}) do
  -- ...
end</code></pre>
<p>The complete rule script for verifying that the lines are no longer than some limit (the limit can be provided as a parameter, but the default value is defined in by the script itself):</p>
<pre><code># Line cannot be too long

set maxLength [getParameter &quot;max-line-length&quot; 100]

foreach f [getSourceFileNames] {
    set lineNumber 1
    foreach line [getAllLines $f] {
        if {[string length $line] &gt; $maxLength} {
            report $f $lineNumber &quot;line is longer than ${maxLength} characters&quot;
        }
        incr lineNumber
    }
}</code></pre>
<p>The above script is actually the implementation of rule L004.</p>
<h2 id="notes-about-line-splicing">Notes about line splicing</h2>
<p>As required by the C++ ISO standard, the line splicing (with the backslash at the end of the line) is performed before tokenizing. This means that the lists of tokens might not strictly fit the list of lines.</p>
<p>Due to the internal mechanisms of the parser, the line splicing freezes the line counter and forces the column counter to continue until the last line in the spliced block. This means that there might be physical non-empty lines that apparently don't have any tokens, as well as tokens that have column numbers not matching the physical source line lengths.</p>
<h2 id="recognized-token-types">Recognized token types</h2>
<p>The following token types are recognized by the parser and can be used for filter selection in the <code>getTokens</code> command (some of these token types are related to compiler extensions):</p>
<pre><code>and
andand
andassign
any
arrow
arrowstar
asm
assign
auto
bool
break
case
catch
ccomment
char
charlit
class
colon
colon_colon
comma
compl
const
constcast
continue
contline
cppcomment
decimalint
default
delete
divide
divideassign
do
dot
dotstar
double
dynamiccast
ellipsis
else
enum
eof
eoi
equal
explicit
export
extern
false
float
floatlit
for
friend
goto
greater
greaterequal
hexaint
identifier
if
inline
int
intlit
leftbrace
leftbracket
leftparen
less
lessequal
long
longintlit
minus
minusassign
minusminus
msext_asm
msext_based
msext_cdecl
msext_declspec
msext_endregion
msext_except
msext_fastcall
msext_finally
msext_inline
msext_int16
msext_int32
msext_int64
msext_int8
msext_leave
msext_region
msext_stdcall
msext_try
mutable
namespace
new
newline
not
notequal
octalint
operator
or
orassign
oror
percent
percentassign
plus
plusassign
plusplus
pound
pound_pound
pp_define
pp_elif
pp_else
pp_endif
pp_error
pp_hheader
pp_if
pp_ifdef
pp_ifndef
pp_include
pp_line
pp_number
pp_pragma
pp_qheader
pp_undef
pp_warning
private
protected
public
question_mark
register
reinterpretcast
return
rightbrace
rightbracket
rightparen
semicolon
shiftleft
shiftleftassign
shiftright
shiftrightassign
short
signed
sizeof
space
space2
star
starassign
static
staticcast
stringlit
struct
switch
template
this
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchart
while
xor
xorassign</code></pre>
<h2 id="note">Note</h2>
<p>There is a predefined rule named <code>DUMP</code> that prints on the screen all tokens with their types and position. This rule can be helpful as a guideline for creating custom filtering criteria:</p>
<pre><code>vera++ --rule DUMP myfile.cpp</code></pre>
<h1 id="changes">Changes</h1>
<h2 id="vera-1.3.0">Vera++ 1.3.0</h2>
<p>The development version of vera++ differs from 1.2.1 in the following ways:</p>
<ul>
<li>Python and Lua support</li>
<li>exclusions are now based on regular expressions - the old tcl format is deprecated but still supported for backward compatibility</li>
<li>profiles are using a new format that allows to put the same options than on the command line - the old tcl format is deprecated but still supported for backward compatibility</li>
<li>rule and transform scripts are now directly in the vera root directory - the old location in the 'scripts' directory is deprecated but still supported for backward compatibility</li>
<li>vera++ executable is now relocatable - the files are located based on the current executable location</li>
<li>the 'no new line at end of file' is not hard coded any more</li>
<li>invalid tokens are reported with the standard report mechanism and are no more blocking the execution</li>
<li>IO error reports contain a description of the failure</li>
<li>error reports are all prefixed with <code>vera++:</code> so we can know which program produces the message when using vera++ in a pipe</li>
<li>test suite enhanced code coverage</li>
<li>BUGFIX: T009 and T019 work properly with OpenMP for directive</li>
<li>BUGFIX: tests are no more failing when run from the distribution archive</li>
<li>BUGFIX: fix segmentation fault when passing an invalid number to the 'report' function in tcl</li>
</ul>
<h2 id="vera-1.2.1">Vera++ 1.2.1</h2>
<p>Vera++ 1.2.1 differs from 1.2.0 in the following ways:</p>
<ul>
<li>BUGFIX: fix <code>--inputs</code> in order to be able to read the inputs from a file</li>
</ul>
<h2 id="vera-1.2.0">Vera++ 1.2.0</h2>
<p>Vera++ 1.2.0 differs from 1.1.2 in the following ways:</p>
<ul>
<li>Full Tcl stack printed when a rule fail.</li>
<li>New command line interface that support long and short options. The old style command line is still usable for backward compatibility.</li>
<li>Produce output to standard output by default so the output can easily be piped to another program. The options <code>--warning</code> and <code>--error</code> make vera++ produce its output on the error output.</li>
<li>CMake macros to easily run vera++ in any CMake project.</li>
<li>Easier integration in a test chain by return an error code when at least one report is produced and the <code>--error</code> option is used. <code>--quiet</code> and <code>--summary</code> can also help to better integrate vera++ in the test chain.</li>
<li>The standard output format match gcc's output format for a better integration in a build chain.</li>
<li>Can read the list of files to check from one or more files.</li>
<li>Can read the source code to check from the standard input.</li>
<li>Can write the several reports in differents formats and in different places.</li>
<li>Added <code>--root</code> option to point the the vera root directory from the command line and ease the usage of custom rules.</li>
<li>Reports can be produced in <a href="http://checkstyle.sourceforge.net/">checkstyle</a> XML format.</li>
<li>Vera++ no more impose the extension of the source files to check.</li>
<li>Several exclusion files can be used.</li>
<li>Several parameter files can be used.</li>
<li>Build system now uses CMake.</li>
<li>Builds with TCL 8.6.</li>
<li>Don't require Boost sources to build.</li>
<li>New documentation generation process to unify the wiki, the html doc and the manpage.</li>
<li>Binary packages for MS Windows and Mac OS X (and others).</li>
<li>Nightly tests to avoid regressions.</li>
<li>New website.</li>
<li>BUGFIX: the rule T019 now works properly with <code>do ... while</code> blocks.</li>
</ul>
<h2 id="vera-1.1.2">Vera++ 1.1.2</h2>
<p>Vera++ 1.1.2 differs from 1.1.1 in the following ways:</p>
<ul>
<li>Added <code>-xmlreport</code> option.</li>
</ul>
<h2 id="vera-1.1.1">Vera++ 1.1.1</h2>
<p>Vera++ 1.1.1 differs from 1.1.0 in the following ways:</p>
<ul>
<li>Added <code>-help</code> option.</li>
<li>Updated code for compatibility with newer versions of Boost. The reference version of the Boost library is now 1.35 or 1.36.</li>
<li>BUGFIX: Corrected handling of current directory when neither <code>HOME</code> nor <code>VERA_ROOT</code> is specified (this affects Windows users only).</li>
</ul>
<h2 id="vera-1.1.0">Vera++ 1.1.0</h2>
<p>Vera++ 1.1.0 differs from 1.0.0 in the following ways:</p>
<ul>
<li>Updated rules:
<ul>
<li>T002: additionally recognizes redefinition (<code>#define</code>) of keywords</li>
<li>T009: recognizes comment adjacent to colon as an exception to the rule</li>
</ul></li>
<li>Added rules:
<ul>
<li>F001: Source files should not use the <code>\r</code> (CR) character</li>
<li>F002: File names should be well-formed Note: F002 is not part of the default profile.</li>
<li>T012: Negation operator should not be used in its short form</li>
<li>T013: Source files should contain the copyright notice</li>
<li>T014: Source files should refer the Boost Software License Note: T014 is not part of the default profile.</li>
<li>T015: HTML links in comments and string literals should be correct</li>
<li>T016: Calls to <code>min</code>/<code>max</code> should be protected against accidental macro substitution</li>
<li>T017: Unnamed namespaces are not allowed in header files</li>
<li>T018: Using namespace is not allowed in header files</li>
<li>T019: Control structures should have complete curly-braced block of code</li>
</ul></li>
<li>Added predefined boost profile to emulate the original Boost inspect tool.</li>
<li>Added transformations:
<ul>
<li>move_namespace: Changes the given identifier, useful for moving the whole project from one namespace to another.</li>
<li>move_macros: Changes the given prefix in all identifiers, useful for moving the whole set of macros that have common prefix.</li>
<li>move_includes: Changes the given part of <code>#include &quot;...&quot;</code> directives, useful for moving libraries and whole sets of header files.</li>
</ul></li>
<li>Added documentation for all available transformations.</li>
<li>Makefiles modified to better support Windows make users.</li>
<li>Extension <code>.ipp</code> added to the list of recognized source file extensions.</li>
<li>New option <code>-showrules</code> includes name of rules in each report line.</li>
<li>Changed the profile definition to be an active Tcl script instead of passive text file.</li>
<li>Added the possibility to define exclusions to rule checks.</li>
<li>BUGFIX: Corrected handling of newline tokens.</li>
</ul>
</body>
</html>
